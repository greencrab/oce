From 4942112ac732dbd7667d8b349ff67c0b2ad5f522 Mon Sep 17 00:00:00 2001
From: Denis Barbier <bouzim@gmail.com>
Date: Thu, 21 Jul 2011 20:00:44 +0200
Subject: [PATCH 20/26] [warning-fix][logical-op-parentheses]

GCC emits warnings:

  src/IntTools/IntTools_FClass2d.cxx:627:28: warning: '&&' within '||' [-Wlogical-op-parentheses]
      if (!RecadreOnPeriodic || !IsUPer && !IsVPer)
                             ^  ~~~~~~~~~~~~~~~~~~
  src/IntTools/IntTools_FClass2d.cxx:627:28: note: place parentheses around the '&&' expression
  to silence this warning
---
 inc/AppParCurves_Variational_7.gxx                 |    4 +-
 inc/Blend_Walking_1.gxx                            |   16 +++++-----
 inc/Contap_ContourGen_2.gxx                        |    8 ++--
 inc/Poly_MakeLoops.hxx                             |    8 ++--
 inc/Quantity_Date.lxx                              |    2 +-
 src/AIS/AIS_LengthDimension.cxx                    |    2 +-
 src/AlienImage/AlienImage_BMPAlienData.cxx         |    6 ++--
 src/AlienImage/AlienImage_GIFLZWDict.cxx           |    2 +-
 src/BRepLib/BRepLib_FindSurface.cxx                |    2 +-
 src/BRepOffset/BRepOffset_Tool.cxx                 |    8 ++--
 src/BRepTest/BRepTest_GPropCommands.cxx            |    2 +-
 src/BRepTopAdaptor/BRepTopAdaptor_FClass2d.cxx     |    4 +-
 src/Bnd/Bnd_Box.cxx                                |    8 ++--
 src/ChFi2d/ChFi2d_Builder.cxx                      |    8 ++--
 src/ChFi3d/ChFi3d_Builder_SpKP.cxx                 |    4 +-
 src/ChFiDS/ChFiDS_FilSpine.cxx                     |    4 +-
 src/DsgPrs/DsgPrs_LengthPresentation.cxx           |    4 +-
 src/DsgPrs/DsgPrs_ShapeDirPresentation.cxx         |    4 +-
 src/Geom2dAdaptor/Geom2dAdaptor.cxx                |    4 +-
 src/GeomAdaptor/GeomAdaptor.cxx                    |    4 +-
 src/IGESData/IGESData_IGESModel.cxx                |    4 +-
 src/IGESToBRep/IGESToBRep_Actor.cxx                |    4 +-
 src/IntPatch/IntPatch_ImpPrmIntersection.cxx       |    8 ++--
 src/IntPatch/IntPatch_LineConstructor.cxx          |    6 ++--
 src/IntPatch/IntPatch_RstInt.cxx                   |   32 ++++++++++----------
 src/IntPoly/IntPoly_ShapeSection.cxx               |   12 ++++----
 src/IntPolyh/IntPolyh_MaillageAffinage.cxx         |    4 +-
 src/IntTools/IntTools_FClass2d.cxx                 |    4 +-
 src/IntTools/IntTools_MarkedRangeSet.cxx           |    4 +-
 src/Intf/Intf_TangentZone.cxx                      |    4 +-
 src/LocOpe/LocOpe_Pipe.cxx                         |    8 ++--
 src/LocOpe/LocOpe_SplitDrafts.cxx                  |    4 +-
 src/MeshVS/MeshVS_NodalColorPrsBuilder.cxx         |    4 +-
 src/PLib/PLib_DoubleJacobiPolynomial.cxx           |    2 +-
 src/PLib/PLib_JacobiPolynomial.cxx                 |    4 +-
 src/PlotMgt/PlotMgt_PlotterParameter.cxx           |    2 +-
 src/Poly/Poly_MakeLoops.cxx                        |    8 ++--
 src/ProjLib/ProjLib_CompProjectedCurve.cxx         |    8 ++--
 src/ProjLib/ProjLib_ComputeApprox.cxx              |    2 +-
 src/ShapeCustom/ShapeCustom_BSplineRestriction.cxx |    2 +-
 src/TopOpeBRepBuild/TopOpeBRepBuild_GridEE.cxx     |    2 +-
 src/TopOpeBRepBuild/TopOpeBRepBuild_GridSS.cxx     |    4 +-
 src/TopOpeBRepBuild/TopOpeBRepBuild_Section.cxx    |    2 +-
 src/TopOpeBRepTool/TopOpeBRepTool_mkTondgE.cxx     |    2 +-
 src/V3d/V3d_CircularGrid.cxx                       |    2 +-
 src/V3d/V3d_RectangularGrid.cxx                    |    5 ---
 src/XCAFPrs/XCAFPrs.cxx                            |    2 +-
 src/Xw/Xw_load_bmp_image.cxx                       |   14 ++++----
 src/Xw/Xw_load_image.cxx                           |    4 +-
 49 files changed, 131 insertions(+), 136 deletions(-)

Index: oce/inc/AppParCurves_Variational_7.gxx
===================================================================
--- oce.orig/inc/AppParCurves_Variational_7.gxx
+++ oce/inc/AppParCurves_Variational_7.gxx
@@ -136,7 +136,7 @@
     vseuil = Sqrt(vocri[1]) + (erold - myMaxError) * 4;
     
 //    if(CNew->NbElements() == TheCurve->NbElements())
-      lrejet = myMaxError > WQuality && myMaxError > erold * 1.01 
+      lrejet = (myMaxError > WQuality && myMaxError > erold * 1.01)
 	|| Sqrt(myCriterium[1]) > vseuil * 1.05;
 //    else
 //      lrejet = myMaxError > WQuality && myMaxError > erold * 1.05 
@@ -160,7 +160,7 @@
 
 /*     (7) Test de convergence */
 
-    if (iter >= mxiter && myMaxSegment == CNew->NbElements() || myMaxError < WQuality) {
+    if ((iter >= mxiter && myMaxSegment == CNew->NbElements()) || myMaxError < WQuality) {
       loptim = Standard_False;
     }
     
Index: oce/inc/Blend_Walking_1.gxx
===================================================================
--- oce.orig/inc/Blend_Walking_1.gxx
+++ oce/inc/Blend_Walking_1.gxx
@@ -454,8 +454,8 @@
   if (sens < 0.) {
     Ext1 = line->StartPointOnFirst();
     Ext2 = line->StartPointOnSecond();
-    if (OnS1 && Ext1.NbPointOnRst() == 0 ||
-	!OnS1 && Ext2.NbPointOnRst() == 0) {
+    if ((OnS1 && Ext1.NbPointOnRst() == 0) ||
+	(!OnS1 && Ext2.NbPointOnRst() == 0)) {
       return Standard_False;
     }
     previousP = line->Point(1);
@@ -465,8 +465,8 @@
   else {
     Ext1 = line->EndPointOnFirst();
     Ext2 = line->EndPointOnSecond();
-    if (OnS1 && Ext1.NbPointOnRst() == 0 ||
-	!OnS1 && Ext2.NbPointOnRst() == 0) {
+    if ((OnS1 && Ext1.NbPointOnRst() == 0) ||
+	(!OnS1 && Ext2.NbPointOnRst() == 0)) {
       return Standard_False;
     }
     previousP = line->Point(line->NbPoints());
@@ -487,16 +487,16 @@
 
   Standard_Integer newlength = line->NbPoints();
   if (sens <0.) {
-    if (OnS1 && line->StartPointOnSecond().NbPointOnRst() == 0 ||
-	!OnS1 && line->StartPointOnFirst().NbPointOnRst() == 0) {
+    if ((OnS1 && line->StartPointOnSecond().NbPointOnRst() == 0) ||
+	(!OnS1 && line->StartPointOnFirst().NbPointOnRst() == 0)) {
       line->Remove(1,newlength-length);
       line->SetStartPoints(Ext1,Ext2);
       return Standard_False;
     }
   }
   else {
-    if (OnS1 && line->EndPointOnSecond().NbPointOnRst() == 0 ||
-	!OnS1 && line->EndPointOnFirst().NbPointOnRst() == 0) {
+    if ((OnS1 && line->EndPointOnSecond().NbPointOnRst() == 0) ||
+	(!OnS1 && line->EndPointOnFirst().NbPointOnRst() == 0)) {
       line->Remove(length,newlength);
       line->SetEndPoints(Ext1,Ext2);
       return Standard_False;
Index: oce/inc/Contap_ContourGen_2.gxx
===================================================================
--- oce.orig/inc/Contap_ContourGen_2.gxx
+++ oce/inc/Contap_ContourGen_2.gxx
@@ -491,8 +491,8 @@
 		  LocTrans = TopAbs_EXTERNAL; // et pourquoi pas INTERNAL
 		}
 		else {
-		  if ((test > 0.)&& arcorien == TopAbs_FORWARD ||
-		      (test < 0.)&& arcorien == TopAbs_REVERSED){
+		  if (((test > 0.)&& arcorien == TopAbs_FORWARD) ||
+		      ((test < 0.)&& arcorien == TopAbs_REVERSED)){
 		    LocTrans = TopAbs_FORWARD;
 		  }
 		  else {
@@ -533,8 +533,8 @@
 			  LocTrans = TopAbs_EXTERNAL; // et pourquoi pas INTERNAL
 			}
 			else {
-			  if ((test > 0.)&& arcorien == TopAbs_FORWARD ||
-			      (test < 0.)&& arcorien == TopAbs_REVERSED){
+			  if (((test > 0.)&& arcorien == TopAbs_FORWARD) ||
+			      ((test < 0.)&& arcorien == TopAbs_REVERSED)){
 			    LocTrans = TopAbs_FORWARD;
 			  }
 			  else {
Index: oce/inc/Poly_MakeLoops.hxx
===================================================================
--- oce.orig/inc/Poly_MakeLoops.hxx
+++ oce/inc/Poly_MakeLoops.hxx
@@ -256,10 +256,10 @@
 inline Standard_Boolean IsEqual(const Poly_MakeLoops::Link& theKey1,
                                 const Poly_MakeLoops::Link& theKey2)
 {
-  return (theKey1.node1 == theKey2.node1 &&
-          theKey1.node2 == theKey2.node2 ||
-          theKey1.node1 == theKey2.node2 &&
-          theKey1.node2 == theKey2.node1);
+  return ((theKey1.node1 == theKey2.node1 &&
+           theKey1.node2 == theKey2.node2) ||
+          (theKey1.node1 == theKey2.node2 &&
+           theKey1.node2 == theKey2.node1));
 }
 
 /**
Index: oce/inc/Quantity_Date.lxx
===================================================================
--- oce.orig/inc/Quantity_Date.lxx
+++ oce/inc/Quantity_Date.lxx
@@ -1,5 +1,5 @@
 inline Standard_Boolean Quantity_Date::IsLeap (const Standard_Integer yy){
 
-return ( ( yy % 4 == 0 && yy % 100 != 0 || yy % 400 == 0) 
+return ( ( (yy % 4 == 0 && yy % 100 != 0) || yy % 400 == 0) 
          ? Standard_True : Standard_False );
 }
Index: oce/src/AIS/AIS_LengthDimension.cxx
===================================================================
--- oce.orig/src/AIS/AIS_LengthDimension.cxx
+++ oce/src/AIS/AIS_LengthDimension.cxx
@@ -1092,7 +1092,7 @@
       gp_Lin LengthLine( myPosition, DirOfArrow1 );
       Standard_Real Par1 = ElCLib::Parameter( LengthLine, EndOfArrow1 );
       Standard_Real Par2 = ElCLib::Parameter( LengthLine, EndOfArrow2 );
-      if (Par1 > 0.0 && Par2 > 0.0 || Par1 < 0.0 && Par2 < 0.0)
+      if ((Par1 > 0.0 && Par2 > 0.0) || (Par1 < 0.0 && Par2 < 0.0))
         {
           FirstPoint = myPosition;
           LastPoint  = (Abs( Par1 ) > Abs( Par2 ))? EndOfArrow1 : EndOfArrow2;
Index: oce/src/AlienImage/AlienImage_BMPAlienData.cxx
===================================================================
--- oce.orig/src/AlienImage/AlienImage_BMPAlienData.cxx
+++ oce/src/AlienImage/AlienImage_BMPAlienData.cxx
@@ -133,7 +133,7 @@
   nBitCount = _TestSwapWORD (isOS2Format ? bmch.bcBitCount: bmih.biBitCount);
   if ((nBitCount != 1 &&  nBitCount != 4 && nBitCount != 8 &&
        nBitCount != 16 && nBitCount != 24 && nBitCount != 32) ||
-       isOS2Format && (nBitCount == 16 || nBitCount == 32)) {
+       (isOS2Format && (nBitCount == 16 || nBitCount == 32))) {
     cout << "AlienImage_BMPAlienData::Read() : Bad <nBitCount> value :"
          << nBitCount << " " << isOS2Format << endl << flush;
     goto _ExitReadError;
@@ -291,8 +291,8 @@
                                              : (*ptrByte++ & 0xf0) >> 4;
         }
         // each run must aligned on a word boundary
-        if (iCompression == BI_RLE8 && (bCode & 1) ||
-            iCompression == BI_RLE4 && (bCode & 3))
+        if ((iCompression == BI_RLE8 && (bCode & 1)) ||
+            (iCompression == BI_RLE4 && (bCode & 3)))
           ptrByte ++;
       }
     }
Index: oce/src/AlienImage/AlienImage_GIFLZWDict.cxx
===================================================================
--- oce.orig/src/AlienImage/AlienImage_GIFLZWDict.cxx
+++ oce/src/AlienImage/AlienImage_GIFLZWDict.cxx
@@ -140,7 +140,7 @@
   for (;;) {
 
     if (dict[ idx ].code == UNUSED ||
-        dict[ idx ].prnt == prntCode && dict[ idx ].byte == ( BYTE )chr)
+       (dict[ idx ].prnt == prntCode && dict[ idx ].byte == ( BYTE )chr))
       return idx;
 
     idx = ( idx >= offset ) ? idx - offset : idx + TBL_SIZE - offset;
Index: oce/src/BRepLib/BRepLib_FindSurface.cxx
===================================================================
--- oce.orig/src/BRepLib/BRepLib_FindSurface.cxx
+++ oce/src/BRepLib/BRepLib_FindSurface.cxx
@@ -371,7 +371,7 @@
   //static Standard_Real weakness = 5.0;
   Standard_Real weakness = 5.0;
   //XXf
-  if(dfDist <= myTolerance || dfDist < myTolerance*weakness && Tol<0) { 
+  if(dfDist <= myTolerance || (dfDist < myTolerance*weakness && Tol<0)) { 
     //XXf 
     //myTolReached = dfDist;
     //XXt
Index: oce/src/BRepOffset/BRepOffset_Tool.cxx
===================================================================
--- oce.orig/src/BRepOffset/BRepOffset_Tool.cxx
+++ oce/src/BRepOffset/BRepOffset_Tool.cxx
@@ -952,8 +952,8 @@
   TopExp::Vertices( E1, V11, V12 );
   TopExp::Vertices( E2, V21, V22 );
 
-  if (V11.IsSame(V21) && V12.IsSame(V22) ||
-      V11.IsSame(V22) && V12.IsSame(V21))
+  if ((V11.IsSame(V21) && V12.IsSame(V22)) ||
+      (V11.IsSame(V22) && V12.IsSame(V21)))
     return Standard_True;
 
   return Standard_False;
@@ -1420,8 +1420,8 @@
 
   if (V1onBound && V2onBound)
     {
-      if (TangFirst.IsParallel(RefTangFirst,AngTol) && TangLast.IsParallel(RefTangLast,AngTol) ||
-	  TangFirst.IsParallel(RefTangLast,AngTol)  && TangLast.IsParallel(RefTangFirst,AngTol))
+      if ((TangFirst.IsParallel(RefTangFirst,AngTol) && TangLast.IsParallel(RefTangLast,AngTol)) ||
+	  (TangFirst.IsParallel(RefTangLast,AngTol)  && TangLast.IsParallel(RefTangFirst,AngTol)))
 	{
 	  TrueEdges.Add( Edges(i) );
 	  return Standard_True;
Index: oce/src/BRepTest/BRepTest_GPropCommands.cxx
===================================================================
--- oce.orig/src/BRepTest/BRepTest_GPropCommands.cxx
+++ oce/src/BRepTest/BRepTest_GPropCommands.cxx
@@ -46,7 +46,7 @@
   Standard_Boolean onlyClosed = Standard_False;
   Standard_Real eps = 1.0;
   Standard_Boolean witheps = Standard_False;
-  if(n > 2 && *a[2]=='c' || n > 3 && *a[3]=='c') onlyClosed = Standard_True;
+  if((n > 2 && *a[2]=='c') || (n > 3 && *a[3]=='c')) onlyClosed = Standard_True;
   if(n > 2 && *a[2]!='c' && n != 5) {eps = atof (a[2]); witheps = Standard_True;}
 
   if (witheps){
Index: oce/src/BRepTopAdaptor/BRepTopAdaptor_FClass2d.cxx
===================================================================
--- oce.orig/src/BRepTopAdaptor/BRepTopAdaptor_FClass2d.cxx
+++ oce/src/BRepTopAdaptor/BRepTopAdaptor_FClass2d.cxx
@@ -491,7 +491,7 @@
 	Status = aClassifier.State();
       }
 
-      if (!RecadreOnPeriodic || !IsUPer && !IsVPer)
+      if (!RecadreOnPeriodic || (!IsUPer && !IsVPer))
 	return Status;
       if (Status == TopAbs_IN || Status == TopAbs_ON)
 	return Status;
@@ -623,7 +623,7 @@
 	Status = aClassifier.State();
       }
       
-      if (!RecadreOnPeriodic || !IsUPer && !IsVPer)
+      if (!RecadreOnPeriodic || (!IsUPer && !IsVPer))
 	return Status;
       if (Status == TopAbs_IN || Status == TopAbs_ON)
 	return Status;
Index: oce/src/Bnd/Bnd_Box.cxx
===================================================================
--- oce.orig/src/Bnd/Bnd_Box.cxx
+++ oce/src/Bnd/Bnd_Box.cxx
@@ -815,12 +815,12 @@
   Standard_Real ysmax = Max (ys1, ys2);
 
   if (ysmax-ysmin < eps && (y1-ys1 < eps && ys1-y2 < eps) &&
-      (xsmin-x1 < eps && x1-xsmax < eps || xsmin-x2 < eps && x2-xsmax < eps ||
-       x1-xs1 < eps && xs1-x2 < eps))
+      ((xsmin-x1 < eps && x1-xsmax < eps) || (xsmin-x2 < eps && x2-xsmax < eps) ||
+       (x1-xs1 < eps && xs1-x2 < eps)))
     return Standard_False;
   if (xsmax-xsmin < eps && (x1-xs1 < eps && xs1-x2 < eps) &&
-      (ysmin-y1 < eps && y1-ysmax < eps || ysmin-y2 < eps && y2-ysmax < eps ||
-       y1-ys1 < eps && ys1-y2 < eps))
+      ((ysmin-y1 < eps && y1-ysmax < eps) || (ysmin-y2 < eps && y2-ysmax < eps) ||
+       (y1-ys1 < eps && ys1-y2 < eps)))
     return Standard_False;
 
   if ((xs1 < x1 && xs2 < x1) || (xs1 > x2 && xs2 > x2) ||
Index: oce/src/ChFi2d/ChFi2d_Builder.cxx
===================================================================
--- oce.orig/src/ChFi2d/ChFi2d_Builder.cxx
+++ oce/src/ChFi2d/ChFi2d_Builder.cxx
@@ -1095,8 +1095,8 @@
     if (U1 > Vv1 && U1 > 2.*PI) {
       ElCLib::AdjustPeriodic(0.,2.*PI,Precision::Confusion(),U1,Vv1);
     } // if (U1 ... 
-    if (O1 == TopAbs_FORWARD && OE1 == TopAbs_FORWARD ||
-	O1 == TopAbs_REVERSED && OE1 == TopAbs_REVERSED ) {
+    if ((O1 == TopAbs_FORWARD && OE1 == TopAbs_FORWARD) ||
+	(O1 == TopAbs_REVERSED && OE1 == TopAbs_REVERSED) ) {
       filletEdge = BRepLib_MakeEdge(circle, refSurf,
 				    NewExtr1, NewExtr2, U1, Vv1);
     } // if (O1 == ...
@@ -1106,8 +1106,8 @@
     } // else ...
     if (!Sense) {
       TopAbs_Orientation S1 = filletEdge.Orientation();
-      if (O1 == TopAbs_FORWARD && OE1 == TopAbs_FORWARD ||
-	  O1 == TopAbs_REVERSED && OE1 == TopAbs_REVERSED ) {
+      if ((O1 == TopAbs_FORWARD && OE1 == TopAbs_FORWARD) ||
+	  (O1 == TopAbs_REVERSED && OE1 == TopAbs_REVERSED) ) {
 	filletEdge = BRepLib_MakeEdge(circle, refSurf, 
 				      NewExtr2, NewExtr1, Vv1, U1);
       }
Index: oce/src/ChFi3d/ChFi3d_Builder_SpKP.cxx
===================================================================
--- oce.orig/src/ChFi3d/ChFi3d_Builder_SpKP.cxx
+++ oce/src/ChFi3d/ChFi3d_Builder_SpKP.cxx
@@ -375,8 +375,8 @@
       TopoDS_Face F2 = BS2->ChangeSurface().Face();
       const ChFiDS_CommonPoint& cp1 = SD->Vertex(isfirst,1);
       const ChFiDS_CommonPoint& cp2 = SD->Vertex(isfirst,2);
-      if(!(cp1.IsOnArc() && SearchFace(Spine,cp1,F1,FBID) ||
-	   cp2.IsOnArc() && SearchFace(Spine,cp2,F2,FBID))) { 
+      if(!((cp1.IsOnArc() && SearchFace(Spine,cp1,F1,FBID)) ||
+	   (cp2.IsOnArc() && SearchFace(Spine,cp2,F2,FBID)))) { 
 	tron = ChFi3d_KParticular(Spine,ivois,BS1->ChangeSurface(),BS2->ChangeSurface());
       }
     }
Index: oce/src/ChFiDS/ChFiDS_FilSpine.cxx
===================================================================
--- oce.orig/src/ChFiDS/ChFiDS_FilSpine.cxx
+++ oce/src/ChFiDS/ChFiDS_FilSpine.cxx
@@ -257,7 +257,7 @@
       rad = parandrad(i).Y();
       Standard_Real nextpar = parandrad(i+1).X();
       if (Abs( Uf-par ) <= gp::Resolution() ||
-	  par < Uf && Uf < nextpar && nextpar-Uf > gp::Resolution())
+	  (par < Uf && Uf < nextpar && nextpar-Uf > gp::Resolution()))
 	{
 	  StartRad = rad;
 	  break;
@@ -306,7 +306,7 @@
       rad = parandrad(i).Y();
       Standard_Real nextpar = parandrad(i+1).X();
       if (Abs( Uf-par ) <= gp::Resolution() ||
-	  par < Uf && Uf < nextpar && nextpar-Uf > gp::Resolution())
+	  (par < Uf && Uf < nextpar && nextpar-Uf > gp::Resolution()))
 	{
 	  StartRad = rad;
 	  break;
Index: oce/src/DsgPrs/DsgPrs_LengthPresentation.cxx
===================================================================
--- oce.orig/src/DsgPrs/DsgPrs_LengthPresentation.cxx
+++ oce/src/DsgPrs/DsgPrs_LengthPresentation.cxx
@@ -170,7 +170,7 @@
   Standard_Real Par1 = ElCLib::Parameter( LengthLine, EndOfArrow1 );
   Standard_Real Par2 = ElCLib::Parameter( LengthLine, EndOfArrow2 );
   gp_Pnt FirstPoint, LastPoint;
-  if (Par1 > 0.0 && Par2 > 0.0 || Par1 < 0.0 && Par2 < 0.0)
+  if ((Par1 > 0.0 && Par2 > 0.0) || (Par1 < 0.0 && Par2 < 0.0))
     {
       FirstPoint = OffsetPoint;
       LastPoint  = (Abs( Par1 ) > Abs( Par2 ))? EndOfArrow1 : EndOfArrow2;
@@ -353,7 +353,7 @@
   Standard_Real Par1 = ElCLib::Parameter( LengthLine, AttachmentPoint1 );
   Standard_Real Par2 = ElCLib::Parameter( LengthLine, EndOfArrow2 );
   gp_Pnt FirstPoint, LastPoint;
-  if (Par1 > 0.0 && Par2 > 0.0 || Par1 < 0.0 && Par2 < 0.0)
+  if ((Par1 > 0.0 && Par2 > 0.0) || (Par1 < 0.0 && Par2 < 0.0))
     {
       FirstPoint = OffsetPoint;
       LastPoint  = (Abs( Par1 ) > Abs( Par2 ))? AttachmentPoint1 : EndOfArrow2;
Index: oce/src/DsgPrs/DsgPrs_ShapeDirPresentation.cxx
===================================================================
--- oce.orig/src/DsgPrs/DsgPrs_ShapeDirPresentation.cxx
+++ oce/src/DsgPrs/DsgPrs_ShapeDirPresentation.cxx
@@ -179,8 +179,8 @@
     pt = lProps.Value();
     dir = lProps.Normal();
   }
-  if ((shape.Orientation() == TopAbs_FORWARD) && (mode == 1) ||
-      (shape.Orientation() == TopAbs_REVERSED) && (mode == 0)) {
+  if ((shape.Orientation() == TopAbs_FORWARD && mode == 1) ||
+      (shape.Orientation() == TopAbs_REVERSED && mode == 0)) {
     dir.Reverse();
   }
   return Standard_True;
Index: oce/src/Geom2dAdaptor/Geom2dAdaptor.cxx
===================================================================
--- oce.orig/src/Geom2dAdaptor/Geom2dAdaptor.cxx
+++ oce/src/Geom2dAdaptor/Geom2dAdaptor.cxx
@@ -87,8 +87,8 @@
 
   // trim the curve if necassary.
   if (! C2D.IsNull() &&
-      (HC.FirstParameter() != C2D->FirstParameter()) ||
-      (HC.LastParameter()  != C2D->LastParameter())) {
+      ((HC.FirstParameter() != C2D->FirstParameter()) ||
+       (HC.LastParameter()  != C2D->LastParameter()))) {
 
     C2D = new Geom2d_TrimmedCurve
       (C2D,HC.FirstParameter(),HC.LastParameter());
Index: oce/src/GeomAdaptor/GeomAdaptor.cxx
===================================================================
--- oce.orig/src/GeomAdaptor/GeomAdaptor.cxx
+++ oce/src/GeomAdaptor/GeomAdaptor.cxx
@@ -75,8 +75,8 @@
 
   // trim the curve if necassary.
   if (! C.IsNull() &&
-      (HC.FirstParameter() != C->FirstParameter()) ||
-      (HC.LastParameter()  != C->LastParameter())) {
+      ((HC.FirstParameter() != C->FirstParameter()) ||
+       (HC.LastParameter()  != C->LastParameter()))) {
 
     C = new Geom_TrimmedCurve(C,HC.FirstParameter(),HC.LastParameter());
   }
Index: oce/src/IGESData/IGESData_IGESModel.cxx
===================================================================
--- oce.orig/src/IGESData/IGESData_IGESModel.cxx
+++ oce/src/IGESData/IGESData_IGESModel.cxx
@@ -497,7 +497,7 @@
   else if ((stdvar->Value(7) != '.' || stdvar->Value(10) > '5' || stdvar->Value(12) > '5')&&(stdvar->Length() == 13))
     ach->SendFail(Msg57);
   else if ((stdvar->Value(8) > '2' ||
-	    stdvar->Value(8) == '2' && stdvar->Value(9) > '3')&&(stdvar->Length() == 13)) ach->SendFail(Msg57);  
+	    (stdvar->Value(8) == '2' && stdvar->Value(9) > '3'))&&(stdvar->Length() == 13)) ach->SendFail(Msg57);  
   //smh#13 For long year date 
   else if ( (stdvar->Value(5) > '1' ||
 	     (stdvar->Value(5) == '1' && stdvar->Value(6) > '2'))&&(stdvar->Length() == 15)) ach->SendFail(Msg57);  
@@ -506,7 +506,7 @@
   else if ((stdvar->Value(9) != '.' || stdvar->Value(12) > '5' || stdvar->Value(14) > '5')&&(stdvar->Length() == 15))
     ach->SendFail(Msg57);
   else if ((stdvar->Value(10) > '2' ||
-	    stdvar->Value(10) == '2' && stdvar->Value(11) > '3')&&(stdvar->Length() == 15)) ach->SendFail(Msg57);  
+	    (stdvar->Value(10) == '2' && stdvar->Value(11) > '3'))&&(stdvar->Length() == 15)) ach->SendFail(Msg57);  
   
 }
 
Index: oce/src/IGESToBRep/IGESToBRep_Actor.cxx
===================================================================
--- oce.orig/src/IGESToBRep/IGESToBRep_Actor.cxx
+++ oce/src/IGESToBRep/IGESToBRep_Actor.cxx
@@ -76,8 +76,8 @@
   Standard_Integer typnum = ent->TypeNumber();
   Standard_Integer fornum = ent->FormNumber();
   if (IGESToBRep::IsCurveAndSurface(ent) ||
-      (typnum == 402 && (fornum == 1 || fornum == 7 || 
-                         fornum == 14 || fornum == 15)  ||
+      ((typnum == 402 && (fornum == 1 || fornum == 7 || 
+                          fornum == 14 || fornum == 15))  ||
       (typnum == 408 ) || (typnum == 308)))
     return Standard_True;
 
Index: oce/src/IntPatch/IntPatch_ImpPrmIntersection.cxx
===================================================================
--- oce.orig/src/IntPatch/IntPatch_ImpPrmIntersection.cxx
+++ oce/src/IntPatch/IntPatch_ImpPrmIntersection.cxx
@@ -236,8 +236,8 @@
 	      LocTrans = TopAbs_EXTERNAL; // et pourquoi pas INTERNAL
 	    }
 	    else {
-	      if ((test > 0.)&& arcorien == TopAbs_FORWARD ||
-		  (test < 0.)&& arcorien == TopAbs_REVERSED){
+	      if (((test > 0.)&& arcorien == TopAbs_FORWARD) ||
+		  ((test < 0.)&& arcorien == TopAbs_REVERSED)){
 		LocTrans = TopAbs_FORWARD;
 	      }
 	      else {
@@ -275,8 +275,8 @@
 		      LocTrans = TopAbs_EXTERNAL; // et pourquoi pas INTERNAL
 		    }
 		    else {
-		      if ((test > 0.)&& arcorien == TopAbs_FORWARD ||
-			  (test < 0.)&& arcorien == TopAbs_REVERSED){
+		      if (((test > 0.)&& arcorien == TopAbs_FORWARD) ||
+			  ((test < 0.)&& arcorien == TopAbs_REVERSED)){
 			LocTrans = TopAbs_FORWARD;
 		      }
 		      else {
Index: oce/src/IntPatch/IntPatch_LineConstructor.cxx
===================================================================
--- oce.orig/src/IntPatch/IntPatch_LineConstructor.cxx
+++ oce/src/IntPatch/IntPatch_LineConstructor.cxx
@@ -804,7 +804,7 @@
       Handle(IntPatch_RLine)& rlin = *((Handle(IntPatch_RLine) *)&(slinref(i)));
       for (Standard_Integer is=0; is<2; is++) {
 	Standard_Boolean onFirst = is==0;
-	if(onFirst && rlin->IsArcOnS1() || !onFirst && rlin->IsArcOnS2()) {
+	if((onFirst && rlin->IsArcOnS1()) || (!onFirst && rlin->IsArcOnS2())) {
 	  Handle(Adaptor2d_HCurve2d) arc;
 	  Standard_Real u,v,u1,v1;
 	  if (onFirst) {
@@ -955,8 +955,8 @@
   Standard_Integer is;
   for (is=0; is<2; is++) {
     Standard_Boolean onFirst = is==0;
-    if( onFirst && WLine->HasArcOnS1() ||
-       !onFirst && WLine->HasArcOnS2()) {
+    if( (onFirst && WLine->HasArcOnS1()) ||
+       (!onFirst && WLine->HasArcOnS2())) {
       PiParOnS piParOnS;
       PQuery pIsOnDomS;
       PArcOnS pArcOnS;
Index: oce/src/IntPatch/IntPatch_RstInt.cxx
===================================================================
--- oce.orig/src/IntPatch/IntPatch_RstInt.cxx
+++ oce/src/IntPatch/IntPatch_RstInt.cxx
@@ -680,8 +680,8 @@
 	      tolU = Max(tolULast,tolU); tolV = Max(tolVLast,tolV);
 	    }
 	    Standard_Real nptCh = UMaxCh-UMinCh;
-	    Standard_Boolean isNptLow = nptCh < 10. && nptCh < Nbptlin/100. ||
-	      !Domain->Has3d() && Standard_Integer(nptCh)+1 < Nbptlin;
+	    Standard_Boolean isNptLow = (nptCh < 10. && nptCh < Nbptlin/100.) ||
+	      (!Domain->Has3d() && Standard_Integer(nptCh)+1 < Nbptlin);
 	    if (!isNptLow && !IsSegment2dSmall(Brise,UMinAr,UMaxAr,tolU,tolV)) {
 	      // treat both ends
 	      Standard_Real UMinChP,UMaxChP,UMinArP,UMaxArP;
@@ -782,8 +782,8 @@
 		if (ptsommet.Distance(locpt(j)) <= edgeTol) {
 		  if (possiblyClosed) {
 		    locpt2(j).Coord(U,V);
-		    if (OSurfaceIsUClosed && Abs(U-U2) > tolOUClosed ||
-			OSurfaceIsVClosed && Abs(V-V2) > tolOVClosed)
+		    if ((OSurfaceIsUClosed && Abs(U-U2) > tolOUClosed) ||
+			(OSurfaceIsVClosed && Abs(V-V2) > tolOVClosed))
 		      continue;
 		  }
 		  duplicate = Standard_True;
@@ -812,14 +812,14 @@
 		  // check in 2d
 		  if (SurfaceIsUClosed || SurfaceIsVClosed) {
 		    GetLinePoint2d (L, paramline, OnFirst, U,V);
-		    if (SurfaceIsUClosed && Abs(U-U1) > tolUClosed ||
-			SurfaceIsVClosed && Abs(V-V1) > tolVClosed)
+		    if ((SurfaceIsUClosed && Abs(U-U1) > tolUClosed) ||
+			(SurfaceIsVClosed && Abs(V-V1) > tolVClosed))
 		      found = Standard_False;
 		  }
 		  if (found && (OSurfaceIsUClosed || OSurfaceIsVClosed)) {
 		    GetLinePoint2d (L, paramline, !OnFirst, U,V);
-		    if (OSurfaceIsUClosed && Abs(U-U2) > tolOUClosed ||
-			OSurfaceIsVClosed && Abs(V-V2) > tolOVClosed)
+		    if ((OSurfaceIsUClosed && Abs(U-U2) > tolOUClosed) ||
+			(OSurfaceIsVClosed && Abs(V-V2) > tolOVClosed))
 		      found = Standard_False;
 		  }
 		}
@@ -846,22 +846,22 @@
 					     ? wlin->Vertex(j)
 					     : rlin->Vertex(j));
 		  Standard_Boolean APointOnRstStillExist =
-		    (OnFirst  && Rptline.IsOnDomS1() && Rptline.ArcOnS1() == arc ||
-		     !OnFirst && Rptline.IsOnDomS2() && Rptline.ArcOnS2() == arc);
+		    ((OnFirst  && Rptline.IsOnDomS1() && Rptline.ArcOnS1() == arc) ||
+		     (!OnFirst && Rptline.IsOnDomS2() && Rptline.ArcOnS2() == arc));
 		  if(!APointOnRstStillExist) {
 		    if (possiblyClosed) {
 		      if (SurfaceIsUClosed || SurfaceIsVClosed) {
 			if (OnFirst) Rptline.ParametersOnS1(U,V);
 			else         Rptline.ParametersOnS2(U,V);
-			if (SurfaceIsUClosed && Abs(U-U1) > tolUClosed ||
-			    SurfaceIsVClosed && Abs(V-V1) > tolVClosed)
+			if ((SurfaceIsUClosed && Abs(U-U1) > tolUClosed) ||
+			    (SurfaceIsVClosed && Abs(V-V1) > tolVClosed))
 			  continue;
 		      }
 		      if (OSurfaceIsUClosed || OSurfaceIsVClosed) {
 			if (OnFirst) Rptline.ParametersOnS2(U,V);
 			else         Rptline.ParametersOnS1(U,V);
-			if (OSurfaceIsUClosed && Abs(U-U2) > tolOUClosed ||
-			    OSurfaceIsVClosed && Abs(V-V2) > tolOVClosed)
+			if ((OSurfaceIsUClosed && Abs(U-U2) > tolOUClosed) ||
+			    (OSurfaceIsVClosed && Abs(V-V2) > tolOVClosed))
 			  continue;
 		      }
 		    }
@@ -968,8 +968,8 @@
 		  //   on doit avoir VtxOnArc = True. On duplique le point sur S1
 		  //   en changeant ArcOnS2.
 		  Standard_Boolean OnDifferentRst =
-		    (OnFirst  && ptline.IsOnDomS1() && ptline.ArcOnS1() != arc ||
-		     !OnFirst && ptline.IsOnDomS2() && ptline.ArcOnS2() != arc);
+		    ((OnFirst  && ptline.IsOnDomS1() && ptline.ArcOnS1() != arc) ||
+		     (!OnFirst && ptline.IsOnDomS2() && ptline.ArcOnS2() != arc));
 		  ptline.SetTolerance(vtxTol);
 		  if (   (!ptline.IsVertexOnS1() &&  OnFirst) 
 		      || (!ptline.IsVertexOnS2() && !OnFirst) 
Index: oce/src/IntPoly/IntPoly_ShapeSection.cxx
===================================================================
--- oce.orig/src/IntPoly/IntPoly_ShapeSection.cxx
+++ oce/src/IntPoly/IntPoly_ShapeSection.cxx
@@ -601,12 +601,12 @@
 Standard_Boolean IntPoly_ShapeSection::IsEqual(const gp_Pnt& Pt1,
 					       const gp_Pnt& Pt2)
 { 
-  return ((Pt1.X() <= Pt2.X() && Pt2.X() < Pt1.X()+epsilon ||
-	   Pt2.X() <= Pt1.X() && Pt1.X() < Pt2.X()+epsilon) && 
-	  (Pt1.Y() <= Pt2.Y() && Pt2.Y() < Pt1.Y()+epsilon ||
-	   Pt2.Y() <= Pt1.Y() && Pt1.Y() < Pt2.Y()+epsilon) && 
-	  (Pt1.Z() <= Pt2.Z() && Pt2.Z() < Pt1.Z()+epsilon ||
-	   Pt2.Z() <= Pt1.Z() && Pt1.Z() < Pt2.Z()+epsilon));
+  return (((Pt1.X() <= Pt2.X() && Pt2.X() < Pt1.X()+epsilon) ||
+	   (Pt2.X() <= Pt1.X() && Pt1.X() < Pt2.X()+epsilon)) && 
+	  ((Pt1.Y() <= Pt2.Y() && Pt2.Y() < Pt1.Y()+epsilon) ||
+	   (Pt2.Y() <= Pt1.Y() && Pt1.Y() < Pt2.Y()+epsilon)) && 
+	  ((Pt1.Z() <= Pt2.Z() && Pt2.Z() < Pt1.Z()+epsilon) ||
+	   (Pt2.Z() <= Pt1.Z() && Pt1.Z() < Pt2.Z()+epsilon)));
 }
 
 
Index: oce/src/IntPolyh/IntPolyh_MaillageAffinage.cxx
===================================================================
--- oce.orig/src/IntPolyh/IntPolyh_MaillageAffinage.cxx
+++ oce/src/IntPolyh/IntPolyh_MaillageAffinage.cxx
@@ -2648,7 +2648,7 @@
 	  &&(Abs(SP1.V1()-SP2.V1())<MyConfusionPrecision) ) NbPoints=1;
       if (NbPoints>=2) return(NbPoints);
                      //= remove
-      else if ( ( (pp3>ppe1)&&(pp1<=ppe1)&&(pp2<=ppe1) ) || ( (pp3<ppe1)&&(pp1>=ppe1)&&(pp2>=ppe1) )
+      else if ( ( ( (pp3>ppe1)&&(pp1<=ppe1)&&(pp2<=ppe1) ) || ( (pp3<ppe1)&&(pp1>=ppe1)&&(pp2>=ppe1) ) )
 	       && (NbPoints<2) ) {
 	//there are two sides (common top PT3) that can cut the edge
 	
@@ -2975,7 +2975,7 @@
 	    &&(Abs(SP1.V1()-SP2.V1())<MyConfusionPrecision) ) NbPoints=1;
 	if (NbPoints>=2) return(NbPoints);
 	
-	else if ( ( (pp3>=ppe1)&&(pp1<=ppe1)&&(pp2<=ppe1) ) || ( (pp3<=ppe1)&&(pp1>=ppe1)&&(pp2>=ppe1) )
+	else if ( ( ( (pp3>=ppe1)&&(pp1<=ppe1)&&(pp2<=ppe1) ) || ( (pp3<=ppe1)&&(pp1>=ppe1)&&(pp2>=ppe1) ) )
 		 && (NbPoints<2) ) {
 	  //there are two sides (common top PT3) that can cut the edge
 	  
Index: oce/src/IntTools/IntTools_FClass2d.cxx
===================================================================
--- oce.orig/src/IntTools/IntTools_FClass2d.cxx
+++ oce/src/IntTools/IntTools_FClass2d.cxx
@@ -624,7 +624,7 @@
       Status = aClassifier.State();
     }
     
-    if (!RecadreOnPeriodic || !IsUPer && !IsVPer)
+    if (!RecadreOnPeriodic || (!IsUPer && !IsVPer))
       return Status;
     
     if (Status == TopAbs_IN || Status == TopAbs_ON)
@@ -761,7 +761,7 @@
       Status = aClassifier.State();
     }
     
-    if (!RecadreOnPeriodic || !IsUPer && !IsVPer)
+    if (!RecadreOnPeriodic || (!IsUPer && !IsVPer))
       return Status;
     if (Status == TopAbs_IN || Status == TopAbs_ON)
       return Status;
Index: oce/src/IntTools/IntTools_MarkedRangeSet.cxx
===================================================================
--- oce.orig/src/IntTools/IntTools_MarkedRangeSet.cxx
+++ oce/src/IntTools/IntTools_MarkedRangeSet.cxx
@@ -224,8 +224,8 @@
 {
   Standard_Integer anIndex = 0;
 
-  if(UseLower && (theValue < myRangeSetStorer(1)) ||
-     (!UseLower && (theValue <= myRangeSetStorer(1))))
+  if((UseLower && theValue < myRangeSetStorer(1)) ||
+     (!UseLower && theValue <= myRangeSetStorer(1)))
     anIndex = 0;
   else {
     for(Standard_Integer i = 2; i <= myRangeSetStorer.Length(); i++) {
Index: oce/src/Intf/Intf_TangentZone.cxx
===================================================================
--- oce.orig/src/Intf/Intf_TangentZone.cxx
+++ oce/src/Intf/Intf_TangentZone.cxx
@@ -305,8 +305,8 @@
   Other.ParamOnFirst(c1, d1);
   Other.ParamOnSecond(c2, d2);
 
-  if ((c1<=a1 && a1<=d1 || c1<=b1 && b1<=d1 || a1<=c1 && c1<=b1) &&
-      (c2<=a2 && a2<=d2 || c2<=b2 && b2<=d2 || a2<=c2 && c2<=b2))
+  if (((c1<=a1 && a1<=d1) || (c1<=b1 && b1<=d1) || (a1<=c1 && c1<=b1)) &&
+      ((c2<=a2 && a2<=d2) || (c2<=b2 && b2<=d2) || (a2<=c2 && c2<=b2)))
     return Standard_True;
   return Standard_False;
 }
Index: oce/src/LocOpe/LocOpe_Pipe.cxx
===================================================================
--- oce.orig/src/LocOpe/LocOpe_Pipe.cxx
+++ oce/src/LocOpe/LocOpe_Pipe.cxx
@@ -143,8 +143,8 @@
 	  }
 	  Plref = Handle(Geom_Plane)::DownCast(P)->Pln();
 	  gp_Dir Dirref(Plref.Axis().Direction());
-	  if (Plref.Direct() && orref == TopAbs_REVERSED ||
-	      !Plref.Direct() && orref == TopAbs_FORWARD) {
+	  if ((Plref.Direct() && orref == TopAbs_REVERSED) ||
+	      (!Plref.Direct() && orref == TopAbs_FORWARD)) {
 	    Dirref.Reverse();
 	  }
 	  
@@ -185,8 +185,8 @@
 	      }
 	      gp_Pln Pl = Handle(Geom_Plane)::DownCast(OtherP)->Pln();
 	      gp_Dir Dirpl(Pl.Axis().Direction());
-	      if (Pl.Direct() && orrelat == TopAbs_REVERSED ||
-		  !Plref.Direct() && orrelat == TopAbs_FORWARD) {
+	      if ((Pl.Direct() && orrelat == TopAbs_REVERSED) ||
+		  (!Plref.Direct() && orrelat == TopAbs_FORWARD)) {
 		Dirpl.Reverse();
 	      }
 	      if (Dirpl.Dot(Dirref) > 0) {
Index: oce/src/LocOpe/LocOpe_SplitDrafts.cxx
===================================================================
--- oce.orig/src/LocOpe/LocOpe_SplitDrafts.cxx
+++ oce/src/LocOpe/LocOpe_SplitDrafts.cxx
@@ -1341,8 +1341,8 @@
   if (!Modify) {
     Newpl = Plorig;
     NormalF = Newpl.Axis();
-    if (Newpl.Direct() && F.Orientation() == TopAbs_REVERSED ||
-	!Newpl.Direct() && F.Orientation() == TopAbs_FORWARD) {
+    if ((Newpl.Direct() && F.Orientation() == TopAbs_REVERSED) ||
+	(!Newpl.Direct() && F.Orientation() == TopAbs_FORWARD)) {
       NormalF.Reverse();
     }
     return Standard_True;
Index: oce/src/MeshVS/MeshVS_NodalColorPrsBuilder.cxx
===================================================================
--- oce.orig/src/MeshVS/MeshVS_NodalColorPrsBuilder.cxx
+++ oce/src/MeshVS/MeshVS_NodalColorPrsBuilder.cxx
@@ -162,8 +162,8 @@
   if ( !( DisplayMode & GetFlags() ) || !IsElement )
     return;
 
-  if ( myUseTexture && ( !myTextureCoords.Extent() || !myTextureColorMap.Length() ) || 
-       !myUseTexture && !myNodeColorMap.Extent() )
+  if ( ( myUseTexture && ( !myTextureCoords.Extent() || !myTextureColorMap.Length() ) ) || 
+       ( !myUseTexture && !myNodeColorMap.Extent() ) )
     return;
 
   // subtract the hidden elements and ids to exclude (to minimise allocated memory)
Index: oce/src/PLib/PLib_DoubleJacobiPolynomial.cxx
===================================================================
--- oce.orig/src/PLib/PLib_DoubleJacobiPolynomial.cxx
+++ oce/src/PLib/PLib_DoubleJacobiPolynomial.cxx
@@ -222,7 +222,7 @@
       }
     }
   }
-  while (ErrU > ErrV && ErrV <= EpmsCut || ErrV >= ErrU && ErrU <= EpmsCut);
+  while ((ErrU > ErrV && ErrV <= EpmsCut) || (ErrV >= ErrU && ErrU <= EpmsCut));
 
 //-------------------------- Recuperation des degres -------------------
         
Index: oce/src/PLib/PLib_JacobiPolynomial.cxx
===================================================================
--- oce.orig/src/PLib/PLib_JacobiPolynomial.cxx
+++ oce/src/PLib/PLib_JacobiPolynomial.cxx
@@ -44,11 +44,11 @@
 void PLib_JacobiPolynomial::Points(const Standard_Integer NbGaussPoints, 
                                    TColStd_Array1OfReal& TabPoints) const 
 {
-  if (NbGaussPoints != NDEG8  && NbGaussPoints != NDEG10 &&  
+  if((NbGaussPoints != NDEG8  && NbGaussPoints != NDEG10 &&  
       NbGaussPoints != NDEG15 && NbGaussPoints != NDEG20 && 
       NbGaussPoints != NDEG25 && NbGaussPoints != NDEG30 && 
       NbGaussPoints != NDEG40 && NbGaussPoints != NDEG50 && 
-      NbGaussPoints != NDEG61 || 
+      NbGaussPoints != NDEG61) || 
       NbGaussPoints <= myDegree)
     Standard_ConstructionError::Raise("Invalid NbGaussPoints");
 
Index: oce/src/PlotMgt/PlotMgt_PlotterParameter.cxx
===================================================================
--- oce.orig/src/PlotMgt/PlotMgt_PlotterParameter.cxx
+++ oce/src/PlotMgt/PlotMgt_PlotterParameter.cxx
@@ -464,7 +464,7 @@
   if (myType == _T_BOOL) {
     if (myFlags & FLAG_DEFVAL && !myDefValue.IsEmpty()) {
       if (myDefValue.IsEqual("true") ||
-            myDefValue.IsIntegerValue() && myDefValue.IntegerValue())
+            (myDefValue.IsIntegerValue() && myDefValue.IntegerValue()))
         return Standard_True;
     } else
       GET_EMPTY_VALUE_INFO("FALSE");
Index: oce/src/Poly/Poly_MakeLoops.cxx
===================================================================
--- oce.orig/src/Poly/Poly_MakeLoops.cxx
+++ oce/src/Poly/Poly_MakeLoops.cxx
@@ -409,8 +409,8 @@
       Standard_Integer aInd = myMapLink.FindIndex(aL);
       if (aInd == 0 || aInd == aIndex)
         continue;
-      if (isOut && aNode1 == aL.node1 ||
-          !isOut && aNode1 == aL.node2)
+      if ((isOut && aNode1 == aL.node1) ||
+          (!isOut && aNode1 == aL.node2))
         aInd = -aInd;
       if (canLinkBeTaken(aInd))
         nEdges++;
@@ -436,8 +436,8 @@
       Standard_Integer aInd = myMapLink.FindIndex(aL);
       if (aInd == 0 || aInd == aIndex)
         continue;
-      if (isOut && aNode1 == aL.node2 ||
-          !isOut && aNode1 == aL.node1)
+      if ((isOut && aNode1 == aL.node2) ||
+          (!isOut && aNode1 == aL.node1))
         aInd = -aInd;
       if (canLinkBeTaken(aInd))
       {
Index: oce/src/ProjLib/ProjLib_CompProjectedCurve.cxx
===================================================================
--- oce.orig/src/ProjLib/ProjLib_CompProjectedCurve.cxx
+++ oce/src/ProjLib/ProjLib_CompProjectedCurve.cxx
@@ -1385,8 +1385,8 @@
            TUdisc.Append(mySequence->Value(i)->Value(j).X());
 	else if(Abs(Ur - CutPntsU(k)) <= myTolU) 
            TUdisc.Append(mySequence->Value(i)->Value(j + 1).X());
-	else if(Ul < CutPntsU(k) && CutPntsU(k) < Ur ||
-		Ur < CutPntsU(k) && CutPntsU(k) < Ul) 
+	else if((Ul < CutPntsU(k) && CutPntsU(k) < Ur) ||
+		(Ur < CutPntsU(k) && CutPntsU(k) < Ul))
         {
 	  Standard_Real V;
 	  V = (mySequence->Value(i)->Value(j).Z() 
@@ -1439,8 +1439,8 @@
            TVdisc.Append(mySequence->Value(i)->Value(j).X());
 	else if (Abs(Vr - CutPntsV(k)) <= myTolV) 
            TVdisc.Append(mySequence->Value(i)->Value(j + 1).X());
-	else if(Vl < CutPntsV(k) && CutPntsV(k) < Vr ||
-		Vr < CutPntsV(k) && CutPntsV(k) < Vl) 
+	else if((Vl < CutPntsV(k) && CutPntsV(k) < Vr) ||
+		(Vr < CutPntsV(k) && CutPntsV(k) < Vl))
         {
 	  Standard_Real U;
 	  U = (mySequence->Value(i)->Value(j).Y() 
Index: oce/src/ProjLib/ProjLib_ComputeApprox.cxx
===================================================================
--- oce.orig/src/ProjLib/ProjLib_ComputeApprox.cxx
+++ oce/src/ProjLib/ProjLib_ComputeApprox.cxx
@@ -1107,7 +1107,7 @@
 	number = (Standard_Integer) (Floor((newV-v)/(F.myV2-F.myV1)));
 	dv -= number*(F.myV2-F.myV1);
       }
-    if (F.UCouture || F.VCouture && SType == GeomAbs_Sphere)
+    if (F.UCouture || (F.VCouture && SType == GeomAbs_Sphere))
       {
 	gp_Pnt2d P2d = F.Value( UFirst );
 	number = (Standard_Integer) (Floor((P2d.X()-u)/PI + Epsilon(PI)));
Index: oce/src/ShapeCustom/ShapeCustom_BSplineRestriction.cxx
===================================================================
--- oce.orig/src/ShapeCustom/ShapeCustom_BSplineRestriction.cxx
+++ oce/src/ShapeCustom/ShapeCustom_BSplineRestriction.cxx
@@ -1230,7 +1230,7 @@
   }
   if (aCurve->IsKind(STANDARD_TYPE(Geom2d_BSplineCurve)) || 
     aCurve->IsKind(STANDARD_TYPE(Geom2d_BezierCurve)) ||
-    (aCurve->IsKind(STANDARD_TYPE(Geom2d_OffsetCurve))) && !IsOf )  {
+    ((aCurve->IsKind(STANDARD_TYPE(Geom2d_OffsetCurve))) && !IsOf ))  {
       Standard_Integer Deg=1;
 
       if (aCurve->IsKind(STANDARD_TYPE(Geom2d_BSplineCurve))) {
Index: oce/src/TopOpeBRepBuild/TopOpeBRepBuild_GridEE.cxx
===================================================================
--- oce.orig/src/TopOpeBRepBuild/TopOpeBRepBuild_GridEE.cxx
+++ oce/src/TopOpeBRepBuild/TopOpeBRepBuild_GridEE.cxx
@@ -668,7 +668,7 @@
     // xpu110398 cto 009 L2 : e6ou en v11
     // xpu140898 USA60111 : e9ou (!=0) + e7ou(=0)
     Standard_Boolean INTEXT =       (oriI == TopAbs_INTERNAL) && (TB == TopAbs_IN);
-    INTEXT = INTEXT || (oriI == TopAbs_EXTERNAL) && (TB == TopAbs_OUT);
+    INTEXT = INTEXT || ((oriI == TopAbs_EXTERNAL) && (TB == TopAbs_OUT));
     kpbound = lesmemes && Eclosed && INTEXT; 
     if ( kpbound ) {
       kpbound = vclo.IsSame(VIG);
Index: oce/src/TopOpeBRepBuild/TopOpeBRepBuild_GridSS.cxx
===================================================================
--- oce.orig/src/TopOpeBRepBuild/TopOpeBRepBuild_GridSS.cxx
+++ oce/src/TopOpeBRepBuild/TopOpeBRepBuild_GridSS.cxx
@@ -1315,8 +1315,8 @@
     Standard_Real tolE = BRep_Tool::Tolerance(aE);
     if (tolE > maxDist) maxDist = tolE;
     if (aE.IsEqual(anEdge) ||
-        aE.Orientation() != TopAbs_FORWARD && aE.Orientation() != TopAbs_REVERSED &&
-        aE.IsSame(anEdge))
+        (aE.Orientation() != TopAbs_FORWARD && aE.Orientation() != TopAbs_REVERSED &&
+         aE.IsSame(anEdge)))
       continue;         // the same pcurve
     Handle(Geom2d_Curve) PC = BRep_Tool::CurveOnSurface(aE,aBaseFace,pf,pl);
     if (PC.IsNull()) {
Index: oce/src/TopOpeBRepBuild/TopOpeBRepBuild_Section.cxx
===================================================================
--- oce.orig/src/TopOpeBRepBuild/TopOpeBRepBuild_Section.cxx
+++ oce/src/TopOpeBRepBuild/TopOpeBRepBuild_Section.cxx
@@ -289,7 +289,7 @@
       Standard_Integer nLESDspon = LESDspon.Extent();
 
       if ( nLEspon != 0 && nLESDspon != 0 ) {
-        Standard_Boolean takeE = (rE == 1 && iESD != iRef || iE == iRef);
+        Standard_Boolean takeE = ((rE == 1 && iESD != iRef) || iE == iRef);
 	pE1 =  takeE ? &E : &ESD;
 	pE2 = !takeE ? &E : &ESD;
 	plos1 =  takeE ? &LEspon : &LESDspon;
Index: oce/src/TopOpeBRepTool/TopOpeBRepTool_mkTondgE.cxx
===================================================================
--- oce.orig/src/TopOpeBRepTool/TopOpeBRepTool_mkTondgE.cxx
+++ oce/src/TopOpeBRepTool/TopOpeBRepTool_mkTondgE.cxx
@@ -343,7 +343,7 @@
     Standard_Real dot = tgi.Dot(xxri);
     if (Abs(dot) < FUN_tola())
       {
-	if (!onfi && !onli || closedi)
+	if ((!onfi && !onli) || closedi)
 	  { mkT = MKI12; return Standard_True; }
 	else
 	  dot = tgi.Dot(tgin1di);
Index: oce/src/V3d/V3d_CircularGrid.cxx
===================================================================
--- oce.orig/src/V3d/V3d_CircularGrid.cxx
+++ oce/src/V3d/V3d_CircularGrid.cxx
@@ -201,7 +201,7 @@
 	switch (DrawMode ()) {
 		default:
 		case Aspect_GDM_Points:
-			if (! myCurAreDefined || myCurAreDefined &&
+			if (! myCurAreDefined ||
 				myCurDrawMode == Aspect_GDM_Lines)
 					myGroup2->Clear ();
 			DefinePoints ();
Index: oce/src/V3d/V3d_RectangularGrid.cxx
===================================================================
--- oce.orig/src/V3d/V3d_RectangularGrid.cxx
+++ oce/src/V3d/V3d_RectangularGrid.cxx
@@ -224,13 +224,8 @@
 	switch (DrawMode ()) {
 		default:
 		case Aspect_GDM_Points:
-#ifdef IMP210100
 			if (! myCurAreDefined || 
 				(myCurDrawMode == Aspect_GDM_Lines) )
-#else
-			if (! myCurAreDefined || myCurAreDefined &&
-				myCurDrawMode == Aspect_GDM_Lines)
-#endif
 					myGroup2->Clear ();
 			DefinePoints ();
 			myCurDrawMode = Aspect_GDM_Points;
Index: oce/src/XCAFPrs/XCAFPrs.cxx
===================================================================
--- oce.orig/src/XCAFPrs/XCAFPrs.cxx
+++ oce/src/XCAFPrs/XCAFPrs.cxx
@@ -107,7 +107,7 @@
     for ( Standard_Integer iL = 1; iL <= LayNames->Length(); iL++) {
       if ( !LTool->IsVisible( LTool->FindLayer(LayNames->Value(iL)) ) ) InVisCount++;
     }
-    if ( InVisCount >0 && InVisCount == LayNames->Length() ||
+    if ( (InVisCount >0 && InVisCount == LayNames->Length() ) ||
          !CTool->IsVisible(lab) ) {
       style.SetVisibility(Standard_False);
     }
Index: oce/src/Xw/Xw_load_bmp_image.cxx
===================================================================
--- oce.orig/src/Xw/Xw_load_bmp_image.cxx
+++ oce/src/Xw/Xw_load_bmp_image.cxx
@@ -117,15 +117,15 @@
 
   /* Detect format using the size field (.biSize or .bcSize) */
   isOS2Format = _TestSwapDWORD (bmfh.dwHeaderSize) == sizeof (bmch) + 4;
-  if (!isOS2Format && sizeof (bmih) != read (fimage, (char *)&bmih, sizeof (bmih))
-    || isOS2Format && sizeof (bmch) != read (fimage, (char *)&bmch, sizeof (bmch)))
+  if ((!isOS2Format && sizeof (bmih) != read (fimage, (char *)&bmih, sizeof (bmih)))
+    || (isOS2Format && sizeof (bmch) != read (fimage, (char *)&bmch, sizeof (bmch))))
     goto _ExitReadError;
 
 
   nBitCount = _TestSwapWORD (isOS2Format? bmch.bcBitCount: bmih.biBitCount);
-  if (nBitCount != 1 && nBitCount != 4 && nBitCount != 8
-      && nBitCount != 16 && nBitCount != 24 && nBitCount != 32
-      || isOS2Format && (nBitCount == 16 || nBitCount == 32)) {
+  if ((nBitCount != 1 && nBitCount != 4 && nBitCount != 8
+      && nBitCount != 16 && nBitCount != 24 && nBitCount != 32)
+      || (isOS2Format && (nBitCount == 16 || nBitCount == 32))) {
 #ifdef DEB
     fprintf (stderr, "\r\nXw_load_bmp_image: "
 	   "Error: Wrong count of bits per pixel (%d) specified!", nBitCount);
@@ -309,8 +309,8 @@
 
 
 	 /* each run must aligned on a word boundary */
-	 if (iCompression == BI_RLE8 && (bCode & 1)
-	     || iCompression == BI_RLE4 && (bCode & 3))
+	 if ((iCompression == BI_RLE8 && (bCode & 1))
+	     || (iCompression == BI_RLE4 && (bCode & 3)))
 	   ptrByte ++;
        }
      }
Index: oce/src/Xw/Xw_load_image.cxx
===================================================================
--- oce.orig/src/Xw/Xw_load_image.cxx
+++ oce/src/Xw/Xw_load_image.cxx
@@ -99,9 +99,9 @@
 		 "\r\nWarning: variable CSF_DefaultImageFormat is undefined!"
 		 " Assuming 'xwd'.\r\n");
       else if (strlen (pchDefExt) != 3 ||
-	          0 != strcasecmp (pchDefExt, "xwd")
+	         (0 != strcasecmp (pchDefExt, "xwd")
 	       && 0 != strcasecmp (pchDefExt, "bmp")
-	       && 0 != strcasecmp (pchDefExt, "gif"))
+	       && 0 != strcasecmp (pchDefExt, "gif")))
         fprintf (stderr,
 		 "\r\nWarning: value '%s' of CSF_DefaultImageFormat "
 		 "is incorrect!\r\n", pchDefExt);
